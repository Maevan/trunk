# coding: utf-8
'''
Created on 2011-12-5

@author: Lv9
'''

print(type(None));#null对象NoneType
#数字
print(type(1));#整型 int
print(type(1.2));#浮点数 float
print(type(False));#布尔型 bool 也可做数字处理1为True 0为False 

#映射
print(type({'a':'b'}));#dict 字典

#序列
print(type('a'));#字符串 str 不可变序列
print(type(['a']));#列表 list
print(type(('a', 'a')));#元组 tuple 很奇怪 如果一个小括号范围内只有一个元素的话 这个类型就不是元组 不可变序列
print(type(range(1, 10)));#整数范围 range

#集合
print(type(set(['1', '2', '3'])))#set 可变集合
print(type(frozenset(['1', '2', '3'])))#frozenset 不可变集合

l = [1, 2, 3, 4, 5, 6, 6, False];

#适用于所有序列的操作和方法
print(len(l));#返回指定序列的长度
print(l[0]);#根据下标获取元素
print(l[0 : 2]);#通过切片运算符返回一个切片
print(l[0 : 7 : 2]);#返回一个拓展切片 最后的位置是步长
print(l.count(6));#返回指定元素出现的次数 PS.说是只适用于列表 但是其他的序列也能用...这书不准
print(min(l));#返回指定列表中最小的元素 仅限于可以排序的序列 比如字符串序列或者数组序列
print(max(l));#返回指定列表中最大的元素 仅限于可以排序的序列 比如字符串序列或者数组序列
print(sum(l));#返回指定列表中全部元素的和 仅限于数字类型
print(all(l));#检查指定列表中全部元素是否为True
print(any(l));#检查指定列表中任意元素是否为True

#适用于可变序列的操作和方法
l[7] = 7; #根据下标赋值
l[6 : 8] = [7];#将原序列中的某个切片替换为指定的序列(必须为序列类型)
l[0 : 7 : 2] = [10, 11, 12, 13];#将序列中某个切片(带步长的..)替换为指定的序列 这个要求比较严格 被替换的切片的元素数量必须与替换的序列长度一致
del l[1];#删除指定下标的元素
del l[1 : 2];#删除指定切片
del l[1 : 4 : 1];#删除指定切片(有步长)

#适用于所有集合
l.append(14);#在末尾追加一个元素
l.extend([15, 16]);#在末尾追加一个序列
l.insert(4, 15);#在指定位置插入元素 第一个参数是位置 第二个参数是值
l.remove(10);#删除指定元素
l.reverse();#颠倒所有元素的顺序
l.sort();#排序 可以通过指定key来针对元素中的某个属性排序 另外可以在结尾处增加reverse来确定是正序还是到倒序
print(l.index(14));#返回指定元素的index 后面有两个可选参数 可以指定查找范围 另外 如果指定元素无法找到会出现异常
print(l.pop(1));#返回指定的元素并且在列表中删除该元素 另外如果不提供参数的话默认是返回 列表中最后一个元素
